Polymorphic Behavior:
Q2. Define a base class Shape with a virtual method Draw. Create derived classes Circle and Rectangle that override this method to draw different shapes. How does polymorphism allow you to call Draw on objects of these derived classes through a base class reference?

Abstract Classes and Polymorphism:
Q3. Explain how abstract classes can be used to achieve polymorphism. Provide an example with an abstract base class and derived classes that implement abstract methods.

Interface Polymorphism:
Q4. Describe how interfaces enable polymorphism in C#. Create an interface IPlayable with a method Play. Implement this interface in classes MusicPlayer and VideoPlayer. Demonstrate how polymorphism allows you to call the Play method on objects of these classes.

Polymorphism in Collections:
Q5. How can you use polymorphism when working with collections in C#? Create a list of type Animal and add objects of various derived classes to it. Show how you can iterate through the list and invoke polymorphic behavior.

Sealed Methods and Polymorphism:
Q6. Explain the impact of using the sealed keyword on a method in a derived class. How does it affect polymorphism? Provide an example to illustrate this concept.

Dynamic Polymorphism vs. Static Polymorphism:
Q7. Differentiate between dynamic polymorphism and static polymorphism. Provide examples to demonstrate both types of polymorphism in C#.

Polymorphism in Method Parameters:
Q8. How can you leverage polymorphism when defining method parameters and arguments? Create a method that accepts a base class object as a parameter and demonstrate how it can work with objects of derived classes.

Polymorphism and Method Resolution:
Q9. Explain how the .NET runtime determines which method to invoke during polymorphic calls. Discuss the role of method tables and virtual method tables (vtables) in method resolution.

Interface Inheritance and Polymorphism:
Q10. How does interface inheritance contribute to polymorphism in C#? Define multiple interfaces and a class that implements them. Show how polymorphism allows objects of the implementing class to be used interchangeably based on the interfaces.
